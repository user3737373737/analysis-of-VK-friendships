from collections import deque

num = int(input())
for i in range(num):
    n, m = map(int, input().split())
    graph = [[] for j in range(n)]
    used = [0] * n

    for j in range(m):
        v, u = map(int, input().split())
        graph[v].append(u)

    start = int(input())

    q = deque()
    d = [987654321] * n


    def bfs(s, q, d):  # v - стартовая вершина
        q.append(s)
        d[s] = 0
        while len(q) != 0:
            v = q.popleft()
            used[v] = 1
            for u in graph[v]:
                if used[u] == 0:
                    q.append(u)
                    d[u] = d[v] + 1


    bfs(start, q, d)
    print(*d)



"""
Нахождение кратчайшего расстояния
пусть до какой-то вершины u найдено кратчайшее расстояние
 и оно равно d, а до вершины v кратчайшее расстояние не меньше,
  чем d. Тогда если вершины u и v – смежны, то кратчайшее расстояние до вершины v равно d+1.
1. Выбрать стартовую вершину
2. Объявляем очередь
3. Помещаем стартовую вершину в очередь и расстояние до нее равно 0
5. Запускаем цикл, пока очередь не пуста
    6. Достаем вершину из списка, в переменную с помощью popleft()
    7. Делаем ее посещенной, used[v] = 1
    8. Запускаем цикл от данной вершины и проходимся по ее смежным вершинам
        9. Проверяем, что они не посещенны
            10. Добавляем в очередь
            11. Высчитываем расстояние до этой вершины, то есть суммы предыдущей (d[v]) и 1
в Массиве d хранятся расстояния
"""