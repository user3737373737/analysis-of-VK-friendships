n, m = map(int, input().split())
graph = [[] for j in range(n)]
used = [0] * n
d = [987654321] * n

for j in range(m):
    v, u, w = map(int, input().split())
    v -=1
    u-=1
    graph[v].append([u, w])


def dijkstra(s, d, used, graph):
    d[s] = 0
    for i in range(n):
        v = -1
        min_d = 987654321
        for j in range(n):
            if used[j] == 0 and d[j] < min_d:
                v = j
                min_d = d[j]

        if v == -1:  # Остались только недостижимые вершины
            return

        for edge in graph[v]:
            u = edge[0]  # сосед вершины v
            w = edge[1]  # вес ребра v->u
            if d[u] > d[v] + w:
                d[u] = d[v] + w

        used[v] = 1


start = int(input())
dijkstra(start, d, used, graph)
print(d)

"""
Алгоритм Дейкстры
Отрицательных ребер нету
Поиск кратчайшего пути
1. Выбираем стартовую вершину
2. В массиве d установим длину стартовой вершины 0, а всем остальным бесконечность
3. Запсускаем цикл для n вершин
    4. Присвоем вершине -1 и сделаем минимальное значение бесконечным
    5. Запускаем цикл для n
    6. Если эта вершина не посещена и ее вес меньше минимального
        7. Эта вершина равна v (v = j), а вес записываем  в минимальное
    9. Если мы так и не обновили вершину (v == -1)
        10. Выходим из программы
    11. Запускаем цикл для смежных вершин графа
        12. Достаем из списка первых вершин, соседа текущй (u) вершина с индексом 0 и вес ребра (w)
        13. Если вес соседа (d[u]) больше чем вес текущей вершина (которая в переменной v) плюс вес этого ребра
            14. Записываем в вес соседа эту сумму
    15. Обозначаем вершину посещенной
"""